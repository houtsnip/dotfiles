set nocompatible " There is no point in being vi compatible (this should also be the first line)

" Put github plugins under .vim/bundle/ -- which allows keeping them updated
" without having to do separate installation.

" Call "filetype off" first to ensure that bundle ftplugins can be added to the
" path before we re-enable it later in the vimrc.
filetype off
execute pathogen#infect()

call pathogen#helptags()

" Alternative file endings for known file-types
autocmd BufNewFile,BufRead *.inc set ft=php
autocmd BufNewFile,BufRead *.phpt set ft=php
autocmd BufNewFile,BufRead *.phtml set ft=php
autocmd BufNewFile,BufRead *.phps set ft=php
autocmd BufNewFile,BufRead *.twig set ft=html
autocmd BufNewFile,BufRead *.less set filetype=less

" Turn on filetype plugins
filetype plugin on
runtime! $HOME/.vim/ftdetect/*.vim

" Remember cursor position when opening a new file
autocmd BufReadPost * normal `"

" Skeleton (template) files...
"autocmd BufNewFile *.html 0r $HOME/.vim/skeleton.html

" Note: The "normal" command afterwards deletes an ugly pending line and moves
" the cursor to the middle of the file.
"autocmd BufNewFile *.php 0r ~/.vim/skeleton.php | normal Gdd

set switchbuf=useopen " reveal already opened files from the
                      " quickfix window instead of opening new
                      " buffers

"set lazyredraw

set backspace=2
set modeline
set modelines=4
" Hit <C-R><C-R> in insert mode after a bad paste
inoremap <silent> <C-R><C-R> <Esc>u:set paste<CR>.:set nopaste<CR>gi
" Use normal mode paste (i.e. "+p) when pasting from clipboard in insert mode
inoremap <silent> <C-R>+ <Esc>"+p`]i
inoremap <silent> <C-R><C-E> <Esc>u@.
" don't move the cursor to the start of the line when changing buffers
set nostartofline
" no bells whatsoever
set vb t_vb=
" 50 milliseconds for escape timeout instead of 1000
set ttimeoutlen=50
" send more data to the terminal in a way that makes the screen update faster
set ttyfast

" Emacs(-like) commands in insert mode for deletion
inoremap <silent> <D-C-D> <Del>
inoremap <silent> <D-BS> <C-W>
imap <silent> <D-C-H> <D-BS>
nnoremap <D-r> q:?

" "Hidden" buffers -- i.e., don't require saving before editing another file.
" Calling quit will prompt you to save unsaved buffers anyways.
set hidden

" Disable suspend Vim
map <C-Z> <Nop>

" Various minor modifications to in-built bindings
"
" Use ~ as an operator
"set tildeop
" Have Y behave analogously to D rather than to dd
nnoremap Y y$
nnoremap <D-Y> v$y
" Delete selection without updating the delete register in visual mode
xnoremap x "_x
xnoremap X "_X
" Replace selection without overwriting the default register in visual mode
xnoremap P p :call setreg('"', getreg('0'))<CR>
" Keep visual selection active when indenting
xnoremap > >gv
xnoremap < <gv
" Don't automatically include the new-line character in visual mode selections
xnoremap $ $h
xnoremap <D-$> $
" Faster viewport scrolling
nnoremap <C-E> 3<C-E>
nnoremap <C-Y> 3<C-Y>
nnoremap <D-C-Y> <C-Y>
nnoremap <D-C-E> <C-E>
vnoremap <C-E> 3<C-E>
vnoremap <C-Y> 3<C-Y>
vnoremap <D-C-Y> <C-Y>
vnoremap <D-C-E> <C-E>
" (Slow) scrolling in insert mode
inoremap <D-C-E> <C-O><C-E>
inoremap <D-C-Y> <C-O><C-Y>
" Make j and k go one line down when lines are wrapped
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk
" Remap ' to ` but not vice-versa (which I think is confusing) and not in
" operator-pending mode (where I think the original meaning is still useful)
nnoremap ' `
xnoremap ' `
nnoremap g' g`
xnoremap g' g`
" Don't prompt for 'Press ENTER or type command to continue' when viewing man pages
nnoremap K K<CR>

" Some people map € or £ (i.e. shift-3) to behave like an American keyboard
" but really this is a waste of a spare key
"map € #
"map £ #
" Map £ to non-operator (i.e. the default) version of ~
"nnoremap £ ~ll

" Define Meta-E as an easier binding for ge (move to end of previous WORD)
nnoremap <D-E> ge
xnoremap <D-E> ge
"nnoremap <D-e> ge
"xnoremap <D-e> ge
"nnoremap <D-E> gE
"xnoremap <D-E> gE
" Fix ge in operator-pending mode - it should behave more like b
onoremap <silent> ge :<C-U>normal! hvgel<CR>
onoremap <silent> gE :<C-U>normal! hvgEl<CR>
omap <silent> <D-E> ge
"omap <silent> <D-e> ge
"omap <silent> <D-E> gE
" : takes two keystrokes, ; takes one; map the latter to the former in normal
" mode to get to the command line faster:
noremap ; :

" Easier bindings for completion in insert mode
" for a file name:
inoremap <D-f> <C-X><C-F>
" for a line:
inoremap <D-l> <C-X><C-L>
" for a tag:
inoremap <D-]> <C-X><C-]>
" for anything - guess (omni):
inoremap <D-o> <C-X><C-O>

" Indentation
"
set modeline
set shiftwidth=4
set expandtab
"set smartindent
"set smarttab
set autoindent
"autocmd BufReadPost php retab! 4
" show the last line even if it doesn't fit - no @
set display=lastline

set showmatch
set matchtime=1

set nofoldenable

set autoread

if v:version > 703 || v:version == 703 && has("patch541")
  set formatoptions+=j " Delete comment character when joining commented lines
endif

" Encoding
"
if has("multi_byte")
  if &termencoding == ""
    let &termencoding = &encoding
  endif
  set encoding=utf-8
  setglobal fileencoding=utf-8 nobomb
  set fileencodings=utf-8,cp1252,latin1
endif

" Mac settings
set noanti
set gfn=Courier:h13

set history=10000
" Use viminfo
" Tell vim to remember certain things when we exit
"  '100  : save marks (a-z) for 100 files
"  f1    : store global marks (A-Z and 0-9)
"  <1000 : save maximum of 1000 lines for each of the registers
"  :10000 : save 1000 lines from the command line history
"  @1000 : save 100 lines from the input line history
"  /1000 : save 100 lines from the search history
"  h     : disable 'hlsearch' highlighting when starting
set viminfo='100,f1,<1000,:10000,@1000,/1000,h

" To avoid the 'Hit ENTER to continue' prompt
set shortmess=aOIstT
" PHP manual using pman man pages
set keywordprg=pman
"source $VIMRUNTIME/ftplugin/man.vim
"nnoremap K :Man --manpath=/usr/share/php/doc/php5-common/PEAR/pman/ <cword><CR>
" Access man pages in insert mode with Meta-K
inoremap <D-k> <C-O>K
silent! nunmap \K

" Do not keep backup files
set nobackup
" Store swap files in one of these directories
set directory=~/.vim/.tmp,~/tmp,/tmp
" Undoing
set undolevels=1000 " maximum number of changes that can be undone
if version >= 703
    set undofile " keep a persistent backup file
    set undodir=~/.vim/.undo,~/tmp,/tmp
    set undoreload=10000 " maximum number lines to save for undo on a buffer reload
endif

" Colours
"
syntax on
set background=dark
colorscheme desert
if version >= 703
    " Highlight bad white-space and other bad characters:
    "
    " Highlight trailing white-space, only not when I'm typing it in insert
    " mode, e.g.
    "
    " Determine if tab- or space-indented by looking at right-most indent
    " character; if it's a tab, then highlight all space indenting, and vice
    " versa, e.g.
    "      	   	tab-indented text
    "	  	        space-indented text
    "
    " Highlight any occurrences of the following (which are usually a
    " mistake):
    "
    " $$
    " ,,
    " 'string literal, followed by EOL'
    "
    " deleted from regex:  \|,\@<=,\|['"]$
    " deleted from regex:  \|\t\+\( \(\s* \)\?\S\)\@=\| \+\(\t\(\s*\t\)\?\S\)\@=
    highlight BadCharacters ctermbg=red
    match BadCharacters /\s\+$\|\$\$\@=/
    autocmd BufWinEnter * match BadCharacters /\s\+$\|\$\$\@=/
    autocmd InsertEnter * match BadCharacters /\s\+\%#\@<!$\|\$\$\@=/
    autocmd InsertLeave * match BadCharacters /\s\+$\|\$\$\@=/
    autocmd BufWinLeave * call clearmatches()
endif

" Show info in ruler
set ruler
set rulerformat=%45(%12f%=\ %m%{'['.(&fenc!=''?&fenc:&enc).']'}\ %l-%v\ %p%%\ [%02B]%)
set laststatus=2
"set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c
" Status-line
"
"hi StatusLine ctermfg=Brown
"hi StatColour ctermfg=White ctermbg=Black
"hi Modified   ctermbg=Red
"au VimEnter * hi Modified ctermbg=Red

function! MyStatusLine(mode)
    let statusline=' #%n '
    if a:mode == 'Enter'
        let statusline.="%#StatColour#"
    endif
    let statusline.="%f"
    if a:mode == 'Enter'
        let statusline.="%*"
    endif
    let statusline .= ' %#Modified#%m%* [%(%R%W%Y%),%{&fenc}:%{&ff}]%* %4*%k%* %{SyntasticStatuslineFlag()} %= 0x%B @ %4*%l%*/%L:%c%V'
    return statusline
endfunction

"if version >= 703
"    au VimEnter * set      statusline=%!MyStatusLine('Enter')
"    au WinEnter * setlocal statusline=%!MyStatusLine('Enter')
"    au WinLeave * setlocal statusline=%!MyStatusLine('Leave')
"else
"    au VimEnter * set      statusline=" #%n %#StatColour#%f%* %#Modified#%m%* [%(%R%W%Y%),%{&fenc}:%{&ff}]%* %4*%k%* %= 0x%B @ %4*%l%*/%L:%c%V"
"    au WinEnter * setlocal statusline=" #%n %#StatColour#%f%* %#Modified#%m%* [%(%R%W%Y%),%{&fenc}:%{&ff}]%* %4*%k%* %= 0x%B @ %4*%l%*/%L:%c%V"
"    au WinLeave * setlocal statusline=" #%n %f [%(%R%W%Y%),%{&fenc}:%{&ff}]%* %4*%k%* %= 0x%B @ %4*%l%*/%L:%c%V"
"endif

"au VimEnter * hi StatusLine ctermfg=Brown
"au WinEnter * hi StatusLine ctermfg=Brown

function! InsertStatuslineColour(mode)
  if a:mode == 'i'
    hi StatusLine ctermbg=Black ctermfg=DarkCyan
  else
    hi StatusLine ctermbg=White ctermfg=DarkBlue
  endif
  if a:mode == 'v'
    hi StatColour ctermbg=Green ctermfg=Black
  endif
endfunction
function! CurDir()
    let curdir = substitute(getcwd(), '/Users/[username]/', "~/", "g")
    return curdir
endfunction
function! HasPaste()
    if &paste
        return '[PASTE MODE]  '
    else
        return ''
    endif
endfunction

"au InsertEnter * call InsertStatuslineColour(v:insertmode)
"au InsertLeave * hi StatusLine ctermfg=Brown ctermbg=Black

" Airline options
let g:airline_theme='mytheme'
"au VimEnter * AirlineTheme mytheme

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
let g:airline_left_sep = ''
"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
let g:airline_right_sep = ''
let g:airline_symbols.crypt = '🔒'
let g:airline_symbols.linenr = '¶'
let g:airline_symbols.maxlinenr = '☰'
let g:airline_symbols.branch = '⎇'
"let g:airline_symbols.paste = 'Þ'
let g:airline_symbols.paste = '𝓟'
let g:airline_symbols.spell = 'Ꞩ'
let g:airline_symbols.notexists = '∄'
let g:airline_symbols.whitespace = 'Ξ'

" Change <Leader> key:
"
let mapleader = ","
let maplocalleader = ","

" Re-map Caps Lock to Escape & get the Meta key working properly
"
" I have re-mapped Caps Lock to F8 in my OS.  Then I have F8 re-mapped to Escape in
" vim, so that I can define Meta-<key> mappings using <D-key>, because in
" my terminal the Meta key just prefixes the following key with Escape.  These
" mappings slow down the Escape key (when used alone), because vim waits to see
" if there is a key following the Escape, which would be interpreted as a
" Meta-<key> mapping.  That's really annoying, because I use Escape all the
" time (to get out of insert mode).  So this redefines the Caps lock as a pure
" mapping to Escape, without having to wait for any other crap.
" It also allows mappings such as Meta-J, which otherwise I cannot define
" because I use the Escape and arrow (h,j,k,l) keys so much that occasionally
" it gets wrongly interpreted as the Meta mapping.
" I chose F8 because it doesn't get used much by anything else
" Get rid of highlighted search results by pressing Leader-Space
noremap <F8> <Esc>
noremap! <F8> <Esc>
cnoremap <F8> <C-C>
nnoremap <silent> <F8> :noh<Bar>:set nois<Bar>:echo<CR><Esc>
" Nice mapping, but I always use hlsearch
"nnoremap <silent> <Leader>h :set hls! hls?<CR>

" Delete all buffers, except for those with unsaved changes
noremap <Leader>bda :bufdo silent! bdelete<CR>

" Use the arrow keys to move between buffers (useful when opening multiple
" files from the command line)
noremap <Right> :bn<CR>
noremap <Left>  :bp<CR>

" Move a line of text using Ctrl-Alt-J / Ctrl-Alt-K
nnoremap <D-C-K> mz:m-2<CR>`z
nnoremap <D-C-J> mz:m+<CR>`z
vnoremap <D-C-K> :m'<-2<CR>`>my`<mzgv`yo`z
vnoremap <D-C-J> :m'>+<CR>`<my`>mzgv`yo`z
nnoremap <D-C-H> <<
nnoremap <D-C-L> >>
vmap <D-C-H> <
vmap <D-C-L> >

" Use Ctrl plus direction key to move around within windows
nnoremap <C-H> <C-W>h
nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
nnoremap <Leader>rd <C-L>
nnoremap <D-+> <C-W>5+
nnoremap <D--> <C-W>5-
nnoremap <D->> <C-W>5>
nnoremap <D-<> <C-W>5<
nmap <D-_> <D-->

" Custom <Leader> macros
"
function! <SID>ConvertTabsToSpaces()
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    %s/\t/        /eg
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction
function! <SID>StripTrailingCarriageReturns()
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    %s/\r\+$//e
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction
function! <SID>StripTrailingWhitespace()
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    %s/\s\+$//e
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction
nmap <silent> <Leader>kt :call <SID>ConvertTabsToSpaces()<CR>
nmap <silent> <Leader>kr :call <SID>StripTrailingCarriageReturns()<CR>
nmap <silent> <Leader>ks :call <SID>StripTrailingWhitespace()<CR>

" Split window vertically
nnoremap <Leader>w <C-W>v<C-W>l

" Search options
"
set ignorecase
set smartcase
"set gdefault " always do substitions with g modifier
set noincsearch
" Meta-/ does incsearch (Escape then turns it off afterwards)
nnoremap <D-/> :set is<CR>/
nnoremap <D-?> :set is<CR>?
set showmatch
set hlsearch
set nowrapscan
autocmd! VimEnter nohlsearch
" Search for definition of function under cursor
nnoremap gfd "zyiw/function\s\+<C-R>z(<CR>
noremap n nzz
sunmap n
noremap N Nzz
sunmap N
"wnoremap * *zz
"sunmap *
"noremap # #zz
"sunmap #
noremap <C-O> <C-O>zz
sunmap <C-O>
noremap <C-I> <C-I>zz
sunmap <C-I>
" Search for selected text in visual mode using * and #
" (one of my favourite mappings)
" xnoremap * :<C-U>let @x = @"<CR>gvy/<C-R>=substitute(escape(@", '/^$[.*~\\'), '\n', '\\n', 'g')<CR><CR>zz:let @" = @x<CR>
" xnoremap # :<C-U>let @x = @"<CR>gvy?<C-R>=substitute(escape(@", '?^$[.*~\\'), '\n', '\\n', 'g')<CR><CR>zz:let @" = @x<CR>
" map <D-*> viW*
" sunmap <D-*>
" map <D-#> viW#
" sunmap <D-#>
nmap *  :set hls<CR><Plug>(operator-*)
nmap <Nop> <Plug>(LoupeStar)
"nmap g* <Plug>(operator-g*)
nmap #  <Plug>(operator-#)
"nmap g# <Plug>(operator-g#)

" Scroll back through last (forwards) searches with Meta-P
nnoremap <D-p> /<C-P>
nnoremap <D-C-P> ?<C-P>
" Scroll back through last (backward) searches with Meta-Ctrl-P
cnoremap <D-p> <C-P>
cnoremap <D-C-P> <C-P>

" Add single character at the beginning / end of a line with Meta-I / Meta-A
"nnoremap <D-i> 0i<Space><Esc>r
"nnoremap <D-a> A<Space><Esc>r

" Open help in a vertically-split window 80 columns wide, on the right
cnoremap <F1> vertical rightbelow help<CR>80<C-W><Bar>:help<Space>
nmap <Leader>h :<F1>

" Shortcuts for saving file
cnoremap w!! w !sudo tee % >/dev/null

" Quickly save from any mode except insert mode
nnoremap <D-s> :w<CR>
vmap <D-s> <C-C><D-s>
omap <D-s> <C-C><D-s>
cmap <D-s> <C-C><D-s>
inoremap <D-s> <Nop>

" Quickly close the current window
nnoremap <Leader>q         :q<CR>
nnoremap <Leader><Leader>q :q!<CR>
nnoremap <Leader>wq        :wq<CR>
nmap <Leader><Leader>w :w!!<CR>
nnoremap <Leader>w.  :w %:p:h/.%:e<Left><Left><Left><Left>
nnoremap <Leader>e.  :e %:p:h/.%:e<Left><Left><Left><Left>
nnoremap <Leader>sav. :sav %:p:h/.%:e<Left><Left><Left><Left>
nnoremap <Leader>savc gg/class<CR>:nohls<CR>:call histdel('/', -1)<CR>:let @/ = histget('/', -1)<CR>EET_yE:sav %:p:h/<C-R>0.%:e
nmap <Leader><Leader>savc <Leader>savc<Home><Right><Right><Right>!<End>
nnoremap <Leader>ls :!ls %:p:h/<CR>
nnoremap <Leader>mv :!mv % %:p:h/.%:e<Left><Left><Left><Left>

" Close the current buffer
nnoremap <Leader>bd :Bclose<CR>

" Close all the buffers
nnoremap <Leader>ba :1,300 bd!<CR>

" ag (silver-search) support
set grepprg=ag
let g:ackprg="ag -H --nocolor --nogroup --column"
nnoremap <D-f><D-f> :Ack<Space>
nmap <D-f> <D-f><D-f>
nnoremap <D-f>a :Ack<Space><Space>Symfony/src/Zim<Home><Right><Right><Right><Right>
nmap     <D-f><D-a> <D-f>a
nnoremap <D-f>w :Ack<Space><Space>Symfony/web<Home><Right><Right><Right><Right>
nmap     <D-f><D-w> <D-f>w
nnoremap <D-f>p :Ack<Space><Space>Symfony/web/postcode<Home><Right><Right><Right><Right>
nmap     <D-f><D-p> <D-f>p
nnoremap <D-f>j :Ack<Space><Space>Symfony/web/js --ignore-dir=Symfony/web/js/min --ignore-dir=Symfony/web/js/vendor --js<Home><Right><Right><Right><Right>
nmap     <D-f><D-w> <D-f>w
nnoremap <D-f>v :Ack<Space><Space>Symfony/vendor<Home><Right><Right><Right><Right>
nmap     <D-f><D-v> <D-f>v
nnoremap <D-f>s :Ack<Space><Space>Symfony/vendor/symfony<Home><Right><Right><Right><Right>
nmap     <D-f><D-s> <D-f>s
nnoremap <D-f>d :Ack<Space><Space>Symfony/vendor/doctrine<Home><Right><Right><Right><Right>
nmap     <D-f><D-d> <D-f>d
nnoremap <D-f>t :Ack<Space><Space>twitter-bootstrap/less<Home><Right><Right><Right><Right>
nmap     <D-f><D-t> <D-f>t
nnoremap <D-f>z :Ack<Space><Space>lib/Zend<Home><Right><Right><Right><Right>
nmap     <D-f><D-z> <D-f>z
"cmap <D-f><D-f> <C-C><D-f><D-f>
"imap <D-f><D-f> <Esc><D-f><D-f>
"vmap <D-f><D-f> <Esc><D-f><D-f>
"cmap <D-f> <C-C><D-f>
"imap <D-f> <Esc><D-f>
"vmap <D-f> <Esc><D-f>
"cmap <D-f>a <C-C><D-f>a
"imap <D-f>a <Esc><D-f>a
"vmap <D-f>a <Esc><D-f>a
"cmap <D-f>t <C-C><D-f>t
"imap <D-f>t <Esc><D-f>t
"vmap <D-f>t <Esc><D-f>t
"cmap <D-f>z <C-C><D-f>z
"imap <D-f>z <Esc><D-f>z
"vmap <D-f>z <Esc><D-f>z

" Search for contractions using typewriters’ apostrophe, e.g. don't
nnoremap <D-f>c  /\c\([a-zA-Z0-9}>]'s\<Bar>n't\<Bar>[Iuey]'ve\<Bar>I'm\<Bar>[uey]'re\<Bar>[Iueyt]'\(ll\<Bar>d\)\)/s+1<CR>
nnoremap <D-f>cc /\c\<\(\(can\<Bar>could\<Bar>will\<Bar>would\<Bar>shall\<Bar>should\<Bar>must\<Bar>need\<Bar>do\<Bar>does\<Bar>did\<Bar>are\<Bar>is\<Bar>was\<Bar>were\<Bar>have\<Bar>has\<Bar>had\)\snot\<Bar>I\sam\<Bar>I\shave\<Bar>\(you\<Bar>we\<Bar>they\<Bar>there\)\s\(are\<Bar>have\)\<Bar>\(s\?he\<Bar>it\<Bar>there\)\s\(is\<Bar>has\)\<Bar>\(I\<Bar>you\<Bar>s\?he\<Bar>it\<Bar>we\<Bar>they\<Bar>there\)\s\(will\<Bar>would\<Bar>shall\<Bar>had\)\)\>/<CR>
nnoremap <D-f>cx /\c\<\(I’ve\<Bar>\(you\<Bar>we\<Bar>they\<Bar>there\)’\(re\<Bar>ve\)\<Bar>\(s\?he\<Bar>it\<Bar>there\)’s\<Bar>\(I\<Bar>you\<Bar>s\?he\<Bar>it\<Bar>we\<Bar>they\<Bar>there\)’\(ll\<Bar>d\)\)\snot\>/<CR>
nnoremap <D-f>cs /\c\([a-zA-Z0-9}]s'\)/s+2<CR>


" Search for git conflict markers
nnoremap <D-f>gc /^\(<<<<<<<\<Bar>=======\<Bar>>>>>>>>\)<CR>

" GitGutter update time (in milliseconds)
set updatetime=250
let g:gitgutter_max_signs = 4000

" Syntastic options
"
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" snipMate options
let g:snippets_dir = $HOME . "/.vim/snippets/"

" NERDTree options
let NERDChristmasTree=1
let NERDTreeCaseSensitiveSort=1
let NERDTreeChDirMode=2
let NERDTreeBookmarksFile = $HOME . "/.vim/NERDTreeBookmarks"
let NERDTreeShowBookmarks=1
let NERDTreeShowHidden=1
let NERDTreeQuitOnOpen=1
let NERDTreeWinSize=46
nnoremap <Leader>n      :OpenBookmark<Space>
nnoremap <silent> <D-N> :NERDTreeToggle<CR>
vmap <D-N> <C-C><D-N>
omap <D-N> <C-C><D-N>
cmap <D-N> <C-C><D-N>

" Startify
let g:startify_change_to_dir = 0
let g:startify_files_number = 5
let g:startify_bookmarks = [
\ { 'a': '~/live.site/private/Symfony/web/app.php' },
\ { 'h': '~/live.site/private/Symfony/web/.htaccess' },
\ { 'p': '~/live.site/private/Symfony/app/config/parameters_common.yml' },
\ { 't': '~/tmp' },
\ { 'v': '~/.vimrc' },
\ ]

" ZenCoding
let g:user_zen_settings = {
\  'indentation':'    ',
\  'php':{
\    'aliases':{
\    },
\    'snippets':{
\      'req':"require_once '';",
\      'inc':"include_once '';",
\      'thr':"throw new Exception();\n",
\    }
\  }
\}
let g:user_zen_leader_key = '<C-G>'
let g:user_zen_complete_tag = 1

" argumentrewrap binding
nnoremap <silent> <Leader>rw :call argumentrewrap#RewrapArguments()<CR>
nnoremap <silent> <Leader><Leader>r :call argumentrewrap#RewrapArguments()<CR>

" Command-T (“CommandT”)
nmap <D-t> :CommandT<CR>
vmap <D-t> <C-C><D-t>
omap <D-t> <C-C><D-t>
imap <D-t> <Esc><D-t>
cmap <D-t> <C-C><D-t>
let g:CommandTTraverseSCM        = 'pwd'
let g:CommandTMaxHeight          = 20
let g:CommandTBackspaceMap       = [ '<BS>', '<C-H>' ]
let g:CommandTDeleteMap          = [ '<Del>', '<C-D>' ]
let g:CommandTAcceptSelectionMap = [ '<CR>', '<C-M' ]
let g:CommandTCancelMap          = [ '<C-C>', '<Esc>', '<F8>' ]
let g:CommandTRefreshMap         = '<C-R>'
let g:CommandTCursorLeftMap      = [ '<Left>', '<C-B>' ]
let g:CommandTCursorRightMap     = [ '<Right>', '<C-F>' ]
nnoremap <Leader>t :CommandTFlush<CR>

" EmacsCommandLine
let g:EmacsCommandLineForwardWordMap       = '<D-f>'
let g:EmacsCommandLineBackwardWordMap      = '<D-b>'
let g:EmacsCommandLineKillWordMap          = '<D-d>'
let g:EmacsCommandLineBackwardKillWordMap  = '<D-BS>'

" bufExplorer
let g:bufExplorerSplitOutPathName = 0
let g:bufExplorerSplitRight = 1

" Gundo
nnoremap <silent> <D-U> :GundoToggle<CR>
vmap <D-U> <C-C><D-U>
omap <D-U> <C-C><D-U>
imap <D-U> <Esc><D-U>
cmap <D-U> <C-C><D-U>

" Tags
"
" Load a tag file
" Loads a tag file from ~/.vim.tags/, based on the argument provided. The
" command "Ltag"" is mapped to this function.
function! LoadTags(file)
   let tagspath = $HOME . "/.vim.tags/" . a:file
   let tagcommand = 'set tags+=' . tagspath
   execute tagcommand
endfunction
command! -nargs=1 Ltag :call LoadTags("<args>")
"call LoadTags("httpdocs")
"call LoadTags("My")
"call LoadTags("Zend")
"call LoadTags("doctrine")
"call LoadTags("fpdf16")
"call LoadTags("project")
"call LoadTags("Elastica")
"call LoadTags("src")
"call LoadTags("vendor")
"set tags+=.git/tags

" TagList
nnoremap <silent> <D-m> :TlistToggle<CR>
vmap <D-m> <C-C><D-m>
omap <D-m> <C-C><D-m>
imap <D-m> <Esc><D-m>
cmap <D-m> <C-C><D-m>
let Tlist_Use_Right_Window = 1
let Tlist_Compact_Format = 1
let Tlist_Exit_OnlyWindow = 1
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_File_Fild_Auto_Close = 1
let Tlist_Inc_Winwidth = 0
let Tlist_Close_On_Select = 1
let Tlist_Process_File_Always = 1
let Tlist_Display_Prototype = 0
let Tlist_Display_Tag_Scope = 1

" VCSCommand
"let VCSCommandSplit = 'vertical'
"let VCSCommandMapPrefix = '<Leader>s'

" NERD Commenter:
" Put a space after comments, like // foo instead of //foo
let NERDSpaceDelims=1
let NERDCreateDefaultMappings=0

" Scratch
nnoremap <Leader>s :Scratch<CR>

" CheckSyntax
let g:checksyntax = {
    \ 'php': {
        \ 'auto': 0,
        \ 'cmd': 'php -l',
        \ 'efm': '%*[^:]: %m in %f on line %l',
        \ 'okrx': 'No syntax errors detected in ',
        \ 'alt': 'phpp'
        \ }
    \ }

" ShowMarks
let g:showmarks_include   = 'qwertasdfgzxcvb'
let g:showmarks_textlower = ' '

" LustyJuggler
nnoremap <D-b> :LustyJuggler<CR>

" DBGp client (remote debugging)
let g:debuggerMaxChildren = 128
nnoremap <Leader>bp :Bp<CR>
nmap <F9> <F2>
nmap <F10> <F3>
nmap <F11> <F4>
nmap <D-"> <F2>
nmap <D-£> <F3>
nmap <D-$> <F4>
nmap <D-%> <F5>
nmap <D-^> <F6>

" run file with PHP CLI (CTRL-M)
autocmd FileType php noremap <Leader><Leader>m :w!<CR>:!/usr/bin/php %<CR>

" PHP parser check
autocmd FileType php noremap <Leader><Leader>l :!/usr/bin/php -l %<CR>

" run file with phpunit
autocmd FileType php noremap <Leader><Leader>t :!phpunit %<CR>

" Code completion
autocmd FileType php set omnifunc=phpcomplete#CompletePHP

"autocmd InsertEnter syn clear EOLWS | syn match EOLWS excludenl /\s\+\%#\@!$/
"autocmd InsertLeave syn clear EOLWS | syn match EOLWS excludenl /\s\+$/
"highlight EOLWS ctermbg=red

function! MakeExecutable()
    silent !chmod a+x %
endfunction
" on save, make file executable if has shebang line with '/bin/'
autocmd BufWritePost * if (getline(1) =~ "^#!.*/bin/") | :call MakeExecutable() | endif

iab lorem Lorem ipsum dolor sit amet, consectetur adipisicing elit
iab llorem Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
iab lllorem Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

" Edit the vimrc file
"nmap <silent> <Leader>ev :e $MYVIMRC<CR>
"nmap <silent> <Leader>sv :so $MYVIMRC<CR>
"autocmd! bufwritepost .vimrc source! %
nnoremap <Leader>; :e ~/.vimrc<CR><C-W>_
"nnoremap <Leader>;! :e! ~/.vimrc<CR><C-W>_
nnoremap <silent> <Leader>: :source ~/.vimrc<CR>:filetype detect<CR>:exe ":echo 'vimrc reloaded'"<CR>
" Execute current line in ex
noremap <Leader><Leader>: 0y$:<C-R>"<CR>

" Copy/Paste Shortcuts
"
" Make the unnamed register the same as the "* register
"set clipboard=unnamed
" copy to system clipboard
vmap <C-C> "+y
" paste in NORMAL mode from system clipboard (at or after cursor)
nmap <Leader>V "+gP
nmap <Leader>v "+gp
" paste in INSERT mode from Vim's clipboard (unnamed register)
"imap vp <ESC>pa
" paste in INSERT mode from system clipboard
"imap vv <ESC>"+gpa
" paste in COMMAND mode from Vim's clipboard (unnamed register)
"cmap vp <C-r>"
" paste in COMMAND mode from system clipboard
"cmap vv <C-r>+
set pastetoggle=<F7>
" Yank/paste to the OS clipboard with ,y and ,p
nmap <Leader>y "+y
nmap <Leader>Y "+yy
nmap <Leader>p "+p
nmap <Leader>P "+P
" Copy line - like yyp but keep cursor position
nnoremap <silent> <D-c> :copy .<CR>
imap     <silent> <D-c> <C-O><D-c>
nnoremap <silent> <D-C> :copy .-1<CR>
imap     <silent> <D-C> <C-O><D-C>
" In visual mode, copy selected text and keep selection
xnoremap <D-c> y'<Pgv
xnoremap <D-C> y'>pgv

" Quick command-line ranges
nnoremap <D-;>gg :1,.
nnoremap <D-;>G  :.,$
nnoremap <D-;>:  !!<BS>
nnoremap <D-;>{  :?^$?+1,.
nnoremap <D-;>2{ :?^$??^$?+1,.
nnoremap <D-;>3{ :?^$??^$??^$?+1,.
" (More than 3 paragraphs is probably better done in visual mode)
nnoremap <D-;>}  :.,/^$/-1
nnoremap <D-;>2} :.,/^$//^$/-1
nnoremap <D-;>3} :.,/^$//^$//^$/-1
nnoremap <D-;>ap :?^$?+1,/^$/
nnoremap <D-;>ip :?^$?+1,/^$/-1
nnoremap <D-;>;  :.;+
nnoremap <D-;>'a :'a,.
nnoremap <D-;>'z :.,'z
nnoremap <D-;>/  :.,//-1<Left><Left><Left>
nnoremap <D-;>?  :??+1,.<Home><Right>
nmap     <D-;>a{ !a{<BS>
nmap     <D-;>a} ;a{
nmap     <D-;>aB ;a{
nmap     <D-;>i{ !i{<BS>
nmap     <D-;>i} ;i{
nmap     <D-;>iB ;i{
nmap     <D-;>a( !a(<BS>
nmap     <D-;>a) ;a(
nmap     <D-;>ab ;a(
nmap     <D-;>i( !i(<BS>
nmap     <D-;>i) ;i(
nmap     <D-;>ib ;i(
nnoremap <D-;>at !at<BS>
nnoremap <D-;>it !it<BS>

" Better filter commands
nnoremap !%  :%!
nmap     !gg ;gg!
nmap     !{  ;{!
nmap     !2{ ;2{!
nmap     !3{ ;3{!
nmap     !ap ;ap!
nmap     !ip ;ip!
nmap     !;  ;;!<Left>
nmap     !'a ;'a!
nnoremap !/  :.,//-1!<Left><Left><Left><Left>
nnoremap !?  :??+1,.<Home><Right>

" Substitutions
nnoremap Z%  :%s!!!g<Left><Left><Left>
nmap     Zgg ;ggs!!!g<Left><Left><Left>
nmap     ZG  ;Gs!!!g<Left><Left><Left>
nmap     ZZ  ;;s!!!g<Left><Left><Left>
nmap     Z{  ;{s!!!g<Left><Left><Left>
nmap     Z2{ ;2{s!!!g<Left><Left><Left>
nmap     Z3{ ;3{s!!!g<Left><Left><Left>
nmap     Z}  ;}s!!!g<Left><Left><Left>
nmap     Z2} ;2}s!!!g<Left><Left><Left>
nmap     Z3} ;3}s!!!g<Left><Left><Left>
nmap     Zap ;aps!!!g<Left><Left><Left>
nmap     Zip ;ips!!!g<Left><Left><Left>
nmap     Z;  ;;s!!!g<Home><Right><Right><Right>
nmap     Z'a ;'as!!!g<Left><Left><Left>
nmap     Z'z ;'zs!!!g<Left><Left><Left>
nnoremap Z/  :.,//-1s!!!g<Home><Right><Right><Right>
nnoremap Z?  :??+1,.s!!!g<Home><Right>
nmap     Za{ ;a{s!!!g<Left><Left><Left>
nmap     Za} Za{
nmap     ZaB Za{
nmap     Zi{ ;i{s!!!g<Left><Left><Left>
nmap     Zi} Zi{
nmap     ZiB Zi{
nmap     Za( ;a(s!!!g<Left><Left><Left>
nmap     Za) Za(
nmap     Zab Za(
nmap     Zi( ;i(s!!!g<Left><Left><Left>
nmap     Zi) Zi(
nmap     Zib Zi(
nmap     Zat ;ats!!!g<Left><Left><Left>
nmap     Zit ;its!!!g<Left><Left><Left>
" Do a substitution within this selection
xnoremap Zv  :s!!!g<Left><Left><Left>
" Substitute the selected string
xmap     Z%  "zyZ%<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Zgg "zyZgg<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     ZG  "zyZG<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     ZZ  "zyZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     2ZZ "zy2ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     3ZZ "zy3ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     4ZZ "zy4ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     5ZZ "zy5ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     6ZZ "zy6ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     7ZZ "zy7ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     8ZZ "zy8ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     9ZZ "zy9ZZ<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z{  "zyZ{<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z2{ "zyZ2{<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z3{ "zyZ3{<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z}  "zyZ}<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z2} "zyZ2}<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z3} "zyZ3}<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Zap "zyZap<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Zip "zyZip<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xnoremap Z;  "zy:.;+s!<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR>!!g<Home><Right><Right><Right>
xmap     Z'a "zyZ'a<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Z'z "zyZ'z<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xnoremap Z/  "zy:.,//-1s!<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR>!!g<Home><Right><Right><Right>
xnoremap Z?  "zy:??+1,.s!<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR>!!g<Home><Right>
xmap     Za{ "zyZa{<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Za} Za{
xmap     ZaB Za{
xmap     Zi{ "zyZi{<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Zi} Zi{
xmap     ZiB Zi{
xmap     Za( "zyZa(<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Za) Za(
xmap     Zab Za(
xmap     Zi( "zyZi(<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Zi) Zi(
xmap     Zib Zi(
xmap     Zat "zyZat<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>
xmap     Zit "zyZit<C-R>=substitute(escape(@z, '!^$[.*~\\'), '\n', '\\n', 'g')<CR><Right>

" Pull word under cursor into LHS of a substitution!
nnoremap Zw%  "zyiw:%s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nnoremap Zw%  "zyiw:%s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwgg "zyiw;ggs!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     ZwG  "zyiw;Gs!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nnoremap Zww  "zyiw:.s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw{  "zyiw;{s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw2{ "zyiw;2{s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw3{ "zyiw;3{s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw}  "zyiw;}s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw2} "zyiw;2}s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw3} "zyiw;3}s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwap "zyiw;aps!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwip "zyiw;ips!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw;  "zyiw;;s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Home><Right><Right><Right>
nmap     Zw'a "zyiw;'as!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zw'z "zyiw;'zs!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nnoremap Zw/  "zyiw:.,//-1s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Home><Right><Right><Right>
nnoremap Zw?  "zyiw:??+1,.s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Home><Right>
nmap     2Zww Zw;1<End><Left><Left>
nmap     3Zww Zw;2<End><Left><Left>
nmap     4Zww Zw;3<End><Left><Left>
nmap     5Zww Zw;4<End><Left><Left>
nmap     6Zww Zw;5<End><Left><Left>
nmap     7Zww Zw;6<End><Left><Left>
nmap     8Zww Zw;7<End><Left><Left>
nmap     9Zww Zw;8<End><Left><Left>
nmap     Zwa{ "zyiw;a{s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwa} Zwa{
nmap     ZwaB Zwa{
nmap     Zwi{ "zyiw;i{s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwi} Zwi{
nmap     ZwiB Zwi{
nmap     Zwa( "zyiw;a(s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwa) Zwa(
nmap     Zwab Zwa(
nmap     Zwi( "zyiw;i(s!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwi) Zwi(
nmap     Zwib Zwi(
nmap     Zwat "zyiw;ats!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>
nmap     Zwit "zyiw;its!\<<C-R>=escape(@z, '!^$[.*~\\')<CR>\>!!g<Left><Left>

" Pull WORD under cursor into LHS of a substitution!
nnoremap ZW%  "zyiW:%s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nnoremap ZW%  "zyiW:%s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWgg "zyiW;ggs!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWG  "zyiW;Gs!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nnoremap ZWW  "zyiW:.s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW{  "zyiW;{s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW2{ "zyiW;2{s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW3{ "zyiW;3{s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW}  "zyiW;}s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW2} "zyiW;2}s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW3} "zyiW;3}s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWap "zyiW;aps!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWip "zyiW;ips!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW;  "zyiW;;s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Home><Right><Right><Right>
nmap     ZW'a "zyiW;'as!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZW'z "zyiW;'zs!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nnoremap ZW/  "zyiW:.,//-1s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Home><Right><Right><Right>
nnoremap ZW?  "zyiW:??+1,.s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Home><Right>
nmap     2ZWW ZW;1<End><Left><Left>
nmap     3ZWW ZW;2<End><Left><Left>
nmap     4ZWW ZW;3<End><Left><Left>
nmap     5ZWW ZW;4<End><Left><Left>
nmap     6ZWW ZW;5<End><Left><Left>
nmap     7ZWW ZW;6<End><Left><Left>
nmap     8ZWW ZW;7<End><Left><Left>
nmap     9ZWW ZW;8<End><Left><Left>
nmap     ZWa{ "zyiW;a{s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWa} ZWa{
nmap     ZWaB ZWa{
nmap     ZWi{ "zyiW;i{s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWi} ZWi{
nmap     ZWiB ZWi{
nmap     ZWa( "zyiW;a(s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWa) ZWa(
nmap     ZWab ZWa(
nmap     ZWi( "zyiW;i(s!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWi) ZWi(
nmap     ZWib ZWi(
nmap     ZWat "zyiW;ats!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>
nmap     ZWit "zyiW;its!\(^\<Bar>\s\)\@<=<C-R>=escape(@z, '!^$[.*~\\')<CR>\($\<Bar>\s\)\@=!!g<Left><Left>

" Pull contents of search register into LHS of a substitution
nnoremap Z/%  :%s!<C-R>/!!g<Left><Left>
nnoremap Z//  :.s!<C-R>/!!g<Left><Left>

" Repeat-commands
"
" Repeat last command and put cursor at start of change
nnoremap . .`[
" Repeat last command-line change with Meta-.
"nnoremap <D-.> @:
" Move to beginning / end of last change
noremap <D-h> `[
noremap <D-l> `]
" (To select last-inserted text: enter visual mode, then Meta-H)
" Move up/down one line and repeat last command
nnoremap <D-j> j.`[
nnoremap <D-k> k.`[
" Move up/down one line and repeat last command-line change
nnoremap <D-J> j@:
nnoremap <D-K> k@:

nnoremap <S-Tab> <C-^>
nnoremap <D-Tab> <C-^>

"nmap <D-[> [[
"nmap <D-]> ]]

nnoremap <C-P> :<C-P>

" Replace functionality of ; and , with \ and | (on the same key)
"noremap  \     ;
"noremap  <Bar> ,
" Remap ; and , commands so they also work after t and T
" Only do the remapping for normal and visual mode, not operator pending
" Use @= instead of :call to prevent leaving visual mode
"nnoremap <silent> \ @=FixCommaAndSemicolon(";")<CR>
"nnoremap <silent> <Bar> @=FixCommaAndSemicolon(",")<CR>
"xnoremap <silent> \ @=FixCommaAndSemicolon(";")<CR>
"xnoremap <silent> <Bar> @=FixCommaAndSemicolon(",")<CR>
function! FixCommaAndSemicolon(command)
   let s:pos1 = getpos(".")
   execute "normal! " . a:command
   let s:pos2 = getpos(".")
   if s:pos1 == s:pos2
      execute "normal! 2" . a:command
   endif
   return ""
endfunction
"nnoremap <D-|> <Bar>

" <Leader>cd to the dir of the current buffer for current window
cnoremap <D->> %:p:h/
nnoremap <Leader>cd :lcd %:p:h<CR>

nnoremap <silent> <D-,> :BufSurfBack<CR>
nnoremap <silent> <D-.> :BufSurfForward<CR>

nnoremap <Leader>Q Q
nnoremap <Leader>l <C-L>

" Highlight text on the screen matching that under the cursor: Press Meta-; to
" start; each subsequent Meta-' matches one more character.  Meta-@ does the
" same but searches backwards.  Uses marks 'm' and 'n', and register 'm'.
map <D-;> mm
map <D-'> lmn"my`m/<C-R>m<CR>`n
map <D-@> lmn"my`m?<C-R>m<CR>`n
"operator#user#define

" Insert Comment
map <Leader>/ I// <ESC>
" map <Leader>cc <plug>NERDCommenterAlignLeft
" map <Leader>cl <plug>NERDCommenterAlignLeft
" map <Leader>cu <plug>NERDCommenterUncomment
" map <Leader>ci <plug>NERDCommenterToggle

" Also use emacs-style '1' to make this window the only one
map <Leader>1 <C-W>o
map <Leader>2 <C-W>s
map <Leader>3 <C-W>v
" Close window shortcuts
map <Leader>0 <C-W>c

" Quickfix Mappings {{{2
" " Go next/prev error/search result
" map <C-Down> :cn<Enter>
" map <C-Up> :cp<Enter>
"
" " Go to next/previous SET of errors/search results
" map <C-Right> :cnew<CR>
" map <C-Left> :cold<CR>

" function s:GrepCurFile
" Prompts for search text, then lists occurrences
" in the :cope window for easy navigation
function! s:GrepCurFile()
    let v:errmsg = ""
    let text = input("Search for: ", expand("<cword>"))
    let curfile = resolve(expand("%:p"))
    if text != ""
        let cmd = 'Ack ' . text . ' ' . curfile
        exe cmd
    endif
endfunction
nnoremap <Leader>m :call <SID>GrepCurFile()<CR>

" Handles the stupid :bd versus :BD debate
" :BD uses the bufkill thingy, where it will keep the window
" open if there are other buffers in the dam window.
" Problem is that if I open a help file, and issue a :BD, then
" it tries to find the last used buffer, and I want to blast the help window.
function! s:BlastBuffer()
    if &filetype == 'help'
        " Just close it.
        :bw
    else
        " We're going to use :BD from BufKill plugin
        " Check for modifications
        if &modified
            let a:ret_val = confirm("Save changes?", "&Yes\n&No\n&Cancel")
            if a:ret_val == 1
                :w
            elseif a:ret_val == 3
                return
            endif
        endif
        :BW!
    endif
endfunction
map <silent> <Leader>k :call <SID>BlastBuffer()<Enter>

" NextIndent()

" Jump to the next or previous line that has the same level or a lower

" level of indentation than the current line.
"
" exclusive (bool): true: Motion is exclusive
" false: Motion is inclusive
" fwd (bool): true: Go to next line
" false: Go to previous line
" lowerlevel (bool): true: Go to line with lower indentation level
" false: Go to line with the same indentation level
" skipblanks (bool): true: Skip blank lines
" false: Don't skip blank lines
function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
    let line = line('.')
    let column = col('.')
    let lastline = line('$')
    let indent = indent(line)
    let stepvalue = a:fwd ? 1 : -1
    while (line > 0 && line <= lastline)
        let line = line + stepvalue
        if ( ! a:lowerlevel && indent(line) == indent ||
                    \ a:lowerlevel && indent(line) < indent)
            if (! a:skipblanks || strlen(getline(line)) > 0)
                if (a:exclusive)
                    let line = line - stepvalue
                endif
                exe line
                exe "normal " column . "|"
                return
            endif
        endif
    endwhile
endfunc

" Moving back and forth between lines of same or lower indentation.
nnoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
nnoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
nnoremap <silent> [L :call NextIndent(0, 0, 1, 1)<CR>
nnoremap <silent> ]L :call NextIndent(0, 1, 1, 1)<CR>
xnoremap <silent> [l <Esc>:call NextIndent(0, 0, 0, 1)<CR>m'gv''
xnoremap <silent> ]l <Esc>:call NextIndent(0, 1, 0, 1)<CR>m'gv''
xnoremap <silent> [L <Esc>:call NextIndent(0, 0, 1, 1)<CR>m'gv''
xnoremap <silent> ]L <Esc>:call NextIndent(0, 1, 1, 1)<CR>m'gv''
onoremap <silent> [l :call NextIndent(0, 0, 0, 1)<CR>
onoremap <silent> ]l :call NextIndent(0, 1, 0, 1)<CR>
onoremap <silent> [L :call NextIndent(1, 0, 1, 1)<CR>
onoremap <silent> ]L :call NextIndent(1, 1, 1, 1)<CR>

" Quickfix window
"
function! GetBufferList()
  redir =>buflist
  silent! ls
  redir END
  return buflist
endfunction
function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
nmap <silent> <D-4> :call ToggleList("Quickfix List", 'c')<CR>
nmap <silent> <D-5> :call ToggleList("Location List", 'l')<CR>
" map <F3> and <S-F3> to jump between locations in a quickfix list, or
" differences if in window in diff mode
nnoremap <expr> <silent> <D-2> (&diff ? "[c" : ":cprev\<CR>") . 'zz'
nnoremap <expr> <silent> <D-3> (&diff ? "]c" : ":cnext\<CR>") . 'zz'

" Missing digraphs
digraphs -_ 173  " Soft Hyphen (optional hyphen to indicate possible break)
digraphs -? 173  " Soft Hyphen (optional hyphen to indicate possible break)
digraphs ^1 185  " Superscript one (¹)
digraphs ^2 178  " Superscript two (²)
digraphs ^3 179  " Superscript three (³)
digraphs ** 215  " Multiplication sign (×)
digraphs // 247  " Division sign (÷)
digraphs -x 8209 " Non-breaking hyphen
digraphs -0 8210 " Figure dash (‒) (used within numbers (e.g. a phone no) when the dash doesn’t represent minus or a range)
digraphs -n 8211 " En dash (–)
digraphs -m 8212 " Em dash (—r
digraphs -- 8212 " Em dash (—)
digraphs -= 8722 " Minus sign (−)
digraphs zs 8203 " Zero Width Space (i.e. 'break here')
digraphs zb 8203 " Zero Width Space (i.e. 'break here')
digraphs zj 8204 " Zero Width Non-Joiner
digraphs zn 8205 " Zero Width Joiner
digraphs nj 8205 " Zero Width Joiner
digraphs \|- 8224 " Dagger / obelisk (†)
digraphs \|+ 8224 " Dagger / obelisk (†)
digraphs \|= 8225 " Double Dagger / obelisk (‡)
digraphs oo 8226 " Bullet point (•)
digraphs ## 8226 " Bullet point (•)
digraphs .. 8230 " Horizontal Ellipsis (…)
digraphs wj 8288 " Word joiner (not very well supported)
"digraphs Eu 8364 " Euro sign (€)
digraphs tm 8482 " Trademark symbol (™)
digraphs !v 8597 " Up-down arrow (↕)
digraphs <\ 8598 " North West arrow
digraphs /> 8599 " North East arrow
digraphs \> 8600 " South East arrow
digraphs </ 8601 " South West arrow
digraphs O< 8634 " Circular arrow (anti-clockwise)
digraphs O> 8635 " Circular arrow (clockwise)
digraphs =! 8657 " Upwards double arrow
digraphs =v 8659 " Downwards double arrow
digraphs In 9432 " Enclosed lower-case I (like the “information” sign)
digraphs >\| 9654 " Black right-pointing triangle (▶)
digraphs \|> 9655 " White right-pointing triangle (▷)
digraphs \|< 9664 " Black left-pointing triangle (◀)
digraphs <\| 9665 " White left-pointing triangle (◁)
digraphs <P 9754 " Black printer’s fist (left)
digraphs P> 9755 " Black printer’s fist (right)
digraphs <p 9756 " Printer’s fist (left)
digraphs p! 9757 " Printer’s fist (up)
digraphs p> 9758 " Printer’s fist (right)
digraphs pv 9759 " Printer’s fist (down)
digraphs v/ 10003 " Check mark
digraphs \/ 10007 " Ballot X
digraphs /\ 10007 " Ballot X
digraphs bm 65279 " Zero Width No-Break Space (Byte Order Mark) (deprecated in favour of Word Joiner)


" Easier-to-type mappings for [] and {}
"noremap! <D-9> [
"noremap! <D-0> ]
"noremap! <D-(> {
"noremap! <D-)> }

" Use ,d (or ,dd or ,dj or 20,dd) to delete a line without adding it to the
" yanked stack (also, in visual mode)
nnoremap <silent> <Leader>d "_d
xnoremap <silent> <Leader>d "_d

" Quick alignment of text
nnoremap <Leader>al :left<CR>
nnoremap <Leader>ar :right<CR>
nnoremap <Leader>ac :center<CR>

" Reselect text that was just pasted with ,v or ,V
nnoremap <Leader>v v`[
nnoremap <Leader>V `]V`[

" Conflict markers {{{
" highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" shortcut to jump to next conflict marker
" nnoremap <silent> <Leader>c /^\(<\\|=\\|>\)\{7\}\([^=].\+\)\?$<CR>

" Creating underline / overline headings for markup languages
nnoremap <Leader>u yypv$r
nnoremap <Leader>o yyPv$r
nmap <Leader>uo- <Leader>u-k<Leader>o-j
nmap <Leader>uo= <Leader>u=k<Leader>o=j
nmap <Leader>uo* <Leader>u*k<Leader>o*j
" Draw a box around
nmap <Leader><Leader>b <Leader>u-A-+<Esc>I+-<D-y>ykPjA <Bar><Esc>I<Bar> <Esc>

" show the registers from things cut/yanked
nnoremap <Leader>r :registers<CR>

" Hints for other movements
" <c-w><c-r> rotate window to next spot
" <c-w><c-x> swap window with current one

" Search for potentially strange non-ascii characters
"map <Leader>u :match Error /[\x7f-\xff]/<CR>

set complete+=.
set complete+=k
set complete+=b
set complete+=t
set completeopt+=menuone,longest

"let g:SuperTabDefaultCompletionType = "context"
"let g:SuperTabContextDefaultCompletionType = "<c-n>"
"let g:SuperTabLongestHighlight = 1
"let g:SuperTabMidWordCompletion = 1

inoremap <D-N> <Space>.<Space>"\n"
inoremap <D-.> ->
inoremap <D->> <Space>=><Space>

nmap qcp gUllguw
nmap qCp gUllguW
nmap qCP qCp

" Convert each name_like_this to NameLikeThis in current line.
xnoremap qCc :s!\(\%(\<\l\+\)\%(_\)\@=\)\|_\(\l\)!\u\1\2!g
" Convert each name_like_this to nameLikeThis in current line.
xnoremap qcc :s!_\(\l\)!\u\1!g

" Delete block leaving contents
nnoremap qdb hf{mm<%%S<Esc>'mS<Esc>
" Put selected text inside block
xnoremap qb ><D-`>[ma`]o<C-D>}<Esc>'aO<C-D>{<Esc>
nmap qbb Vqb
nmap 2qbb Vjqb
nmap 3qbb V2jqb
nmap 4qbb V3jqb
nmap 5qbb V4jqb
nmap 6qbb V5jqb
nmap 7qbb V6jqb
nmap 8qbb V7jqb
nmap 9qbb V8jqb

" Pull line into condition and insert empty block
nmap q) yss)A<CR>{<CR>}<Esc>kki <Esc>i
nmap q( yss(A<CR>{<CR>}<Esc>kki <Esc>i

" Pull selected text into condition and insert empty block
xmap q) S)d^%lC<CR>{<CR>}<Esc>kki <Esc>i
xmap q( S(d^%lC<CR>{<CR>}<Esc>kki <Esc>i

" Out-line an inline function
nnoremap qolf ^f{i<BS><CR><Esc>la<CR><C-T><Esc>f}i<BS><CR><C-D><Esc>%
" Out-line an inline block, e.g.
" if (condition) expression;
nnoremap qolb ^f(%a<CR>{<CR><C-T><Esc>o<C-D>}<Esc>-
" Out-line an inline array
nnoremap qola ^f(%i,<CR><C-T><Esc>l%a<CR><C-T><Esc>k^f(b<Esc>

" Out-line tertiary ?:
nnoremap qol? ^f?a<CR><C-T><Esc>f:a<CR><Esc>

" Convert $array->key to $array['key'] (Array Key)
nmap qak lF-xxveS'gvS]
" Convert $object['property'] to $object->property (Object Property)
nmap qop lF[llds'ds]i-><Esc>h

" Convert $this->method to self::method (Static Call)
nmap qsc lF$cf>self::<Esc>bb
" Convert self::method to $this->method (Dynamic Call)
nmap qdc lBf:Fsc2f:$this-><Esc>F$:nohls<CR>

" Convert echo "blah\n" to throw new Exception("blah") (Throw Exception)
nmap qte ^ct"throw new Exception(<Esc>A<BS><BS><BS><BS>");<Esc>jddk^
" Convert throw new Exception("blah") to echo "blah\n" (Echo Error)
nmap qee ^cf(echo <Esc>A<BS><BS><BS>\n";<CR>exit(1);<Esc>-

" Convert isset($array['key']) to array_key_exists('key', $array)
nmap qfake l?\(isset\<Bar>empty\)(<CR>cwarray_key_exists<Esc>f[di]h"_2xF$Pa, <Esc>?array_key_exists(<CR>:nohls<CR>:call histdel('?', -1)<CR>:let @/ = histget('?', -1)<CR>
nmap qfia l?\(isset\<Bar>empty\)(<CR>cwin_array<Esc>f[di]h"_2xF$Pa, <Esc>?in_array(<CR>:nohls<CR>:call histdel('?', -1)<CR>:let @/ = histget('?', -1)<CR>
" Convert array_key_exists('key', $array) to isset('key', $array) or empty(...)
nmap qfisset l?\(array_key_exists\<Bar>in_array\)(<CR>cwisset<Esc>lldt,"_2xf)i[<C-R>-]<Esc>?isset(<CR>:nohls<CR>:call histdel('?', -1)<CR>:let @/ = histget('?', -1)<CR>
nmap qfempty l?\(array_key_exists\<Bar>in_array\)(<CR>cwempty<Esc>lldt,"_2xf)i[<C-R>-]<Esc>?empty(<CR>:nohls<CR>:call histdel('?', -1)<CR>:let @/ = histget('?', -1)<CR>

" Swap function arguments (PHP)
nnoremap gs :set nohls<CR>l?&\=\$<CR>dt,/&\=\$<CR>v/[,)]/s-1<CR>pF,P/&\=\$<CR>:set hls<CR>:nohls<CR>
nnoremap gS :set nohls<CR>l?&\=\$<CR>d/[,)]<CR>F,hv?&\=\$<CR>pf,lp2?&\=\$<CR>:set hls<CR>:nohls<CR>

nnoremap qaef ^%?\<function\><CR>wye/{<CR>%a // end function <C-R>0<Esc>^:nohls<CR>:call histdel('/', -1)<CR>:let @/ = histget('/', -1)<CR>

" Convert each NameLikeThis to name_like_this in current line.
xnoremap qus :s!\C\(\<\u[a-z0-9]\+\|[a-z0-9]\+\)\(\u\)!\l\1_\l\2!g

" Go to parent class (PHP)
nnoremap <Leader><Leader>p gg/extends<CR>:nohls<CR>:call histdel('/', -1)<CR>:let @/ = histget('/', -1)<CR>w<C-]>

" Split line at cursor
nnoremap S i<CR><Esc>k$
nnoremap <D-S> i<CR><C-D><Esc>k$

" ‘Inside-line’ operator-pending-mode mapping
"onoremap <silent> il :<C-U>normal! ^v$h<CR>
"onoremap <silent> iL :<C-U>normal! 0v$h<CR>

" The plugin ‘textobj-between’ provides the more general mappings ‘ifX’ and
" ‘afX’, where ‘X’ is any character.  These mappings though are particularly
" useful and common:
"onoremap <silent> i. :<C-U>normal! T.vt.<CR>
"onoremap <silent> a. :<C-U>normal! F.vf.<CR>
"onoremap <silent> i/ :<C-U>normal! T/vt/<CR>
"onoremap <silent> a/ :<C-U>normal! F/vf/<CR>
"onoremap <silent> i% :<C-U>normal! T%vt%<CR>
"onoremap <silent> a% :<C-U>normal! F%vf%<CR>
"onoremap <silent> i_ :<C-U>normal! T_vt_<CR>
"onoremap <silent> a_ :<C-U>normal! F_vf_<CR>
onoremap <silent> i. <Plug>(textobj-between-i).
onoremap <silent> a. <Plug>(textobj-between-a).
onoremap <silent> i/ <Plug>(textobj-between-i)/
onoremap <silent> a/ <Plug>(textobj-between-a)/
onoremap <silent> i% <Plug>(textobj-between-i)%
onoremap <silent> a% <Plug>(textobj-between-a)%
onoremap <silent> i_ <Plug>(textobj-between-i)_
onoremap <silent> a_ <Plug>(textobj-between-a)_
onoremap <silent> i{ :<C-U>normal! T}vt{<CR>
onoremap <silent> a{ :<C-U>normal! F}vf{<CR>
"xnoremap il ^o$h
"xnoremap iL 0o$h
xnoremap i/ T/ot/
xnoremap a/ F/of/
xnoremap i. T.ot.
xnoremap a. F.of.
xnoremap i_ T_ot_
xnoremap a_ F_of_
xnoremap i% T%ot%
xnoremap a% F%of%
xnoremap i{ T}ot{
xnoremap a{ F}of{

nnoremap ]k /->\<Bar>::/e+1<CR>
nnoremap [k ?->\<Bar>::?e+1<CR>

" Insert a line above current line, but indented as though inserting a line below
nnoremap <D-o> ko

" Toggle Color Column Keybinding
map <Leader>C :call g:ToggleColorColumn()<CR>"
" Toggle Color Column
function! g:ToggleColorColumn()
    if(&cc == 85)
        set cc=""
    else
        set cc=85
    endif
endfun

" Relative numbering shortcut
nnoremap <Leader>N :call g:ToggleRelativeNumbering()<CR>
" Toggle Relative Numbering Function
function! g:ToggleRelativeNumbering()
    if(&rnu == 1)
        set nu
    else
        set rnu
    endif
endfunc

" Markdown conversion
map <Leader>M :%!markdown<CR>
vmap <Leader>M :!markdown<CR>

nmap <D-Space> ysl<Space><Space>

" Operator-surround
"
nmap <silent>ys <Plug>(operator-surround-append)
nmap <silent>ds <Plug>(operator-surround-delete)
nmap <silent>cs <Plug>(operator-surround-replace)
nmap <silent>yss <Plug>(operator-surround-append)il
nmap <silent>dss <Plug>(operator-surround-delete)il
nmap <silent>css <Plug>(operator-surround-replace)il

" Operator-flashy
"map y <Plug>(operator-flashy)
"nmap Y <Plug>(operator-flashy)$

" Easily insert date in insert mode
inoremap <silent> <C-G><C-T> <C-R>=repeat(complete(col('.'),map(["%Y-%m-%d %H:%M:%S","%d/%m/%Y %H.%M.%S","%a, %d %b %Y %H:%M:%S %z","%Y %b %d","%d-%b-%y","%a %b %d %T %Z %Y"],'strftime(v:val)')+[localtime()]),0)<CR>

" Alignment mappings
xnoremap <Leader>a=  :Align=<CR>
xnoremap <Leader>aa  :Align =><CR>
xnoremap <Leader>a,  :Align! P101 => //<CR>
xnoremap <Leader>a,, :Align! P101 => , //<CR>
xnoremap <Leader>aff :Align! P110 function { }<CR>
xnoremap <Leader>afa :Align! P11110 function { = return }<CR>
nmap <Leader>a=  Vip<Leader>a=
nmap <Leader>aa  vi)Vk<Leader>aa
nmap <Leader>a,  vi)Vk<Leader>a,
nmap <Leader>a,, vi)Vk<Leader>a,,
nmap <Leader>aff Vip<Leader>aff
nmap <Leader>afa Vip<Leader>afa

"iab a's       a’s
"iab b's       b’s
"iab c's       c’s
"iab d's       d’s
"iab e's       e’s
"iab f's       f’s
"iab g's       g’s
"iab h's       h’s
"iab i's       i’s
"iab j's       j’s
"iab k's       k’s
"iab l's       l’s
"iab m's       m’s
"iab n's       n’s
"iab o's       o’s
"iab p's       p’s
"iab q's       q’s
"iab r's       r’s
"iab s's       s’s
"iab t's       t’s
"iab u's       u’s
"iab v's       v’s
"iab w's       w’s
"iab x's       x’s
"iab y's       y’s
"iab z's       z’s
"iab I'm       I’m
"iab you're    you’re
"iab we're     we’re
"iab they're   they’re
"iab I've      I’ve
"iab you've    you’ve
"iab we've     we’ve
"iab they've   they’ve
"iab I'd       I’d
"iab you'd     you’d
"iab he'd      he’d
"iab she'd     she’d
"iab we'd      we’d
"iab they'd    they’d
"iab ain't     ain’t
"iab isn't     isn’t
"iab aren't    aren’t
"iab wasn't    wasn’t
"iab weren't   weren’t
"iab haven't   haven’t
"iab hasn't    hasn’t
"iab hadn't    hadn’t
"iab don't     don’t
"iab didn't    didn’t
"iab can't     can’t
"iab couldn't  couldn’t
"iab won't     won’t
"iab wouldn't  wouldn’t
"iab shan't    shan’t
"iab shouldn't shouldn’t
"iab mustn't   mustn’t
noremap! <D-'> ’
noremap! <D-@> ‘
nnoremap r<D-'> r’
nnoremap r<D-@> r‘

nmap cs"" csa"“f“r”F
nmap cs'" csa'“f“r”F
nmap cs'' csa'‘f‘r’F
nmap cs"' csa"‘f‘r’F

iab pathlink {{ macro.link(path(''), '') }}<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab pathlink# {{ macro.link(path('') ~ '#', '') }}<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab infolink {{ macro.link(path('info', { page: '' }), '') }}<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab infolink# {{ macro.link(path('info', { page: '' }) ~ '#', '') }}<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab questionlink {{ macro.link(path('question', { question: '' }), '', 'help') }}<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
iab phpecho <?php echo htmlspecialchars(); ?><Left><Left><Left><Left><Left>

iab 1st 1<sup>st</sup>
iab 2nd 2<sup>nd</sup>
iab 3rd 3<sup>rd</sup>
iab nth n<sup>th</sup><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

iab nnbsp <span class="nnbsp">&thinsp;</span>

nmap <Leader>e8       :e ++enc=utf-8
nmap <Leader>e16be    :e ++enc=utf-16be
nmap <Leader>e16le    :e ++enc=utf-16le
nmap <Leader>eutf8    :e ++enc=utf-8
nmap <Leader>eutf16be :e ++enc=utf-16be
nmap <Leader>eutf16le :e ++enc=utf-16le

xmap gUc y'<mo'>mpo<Esc>P:.s!\<[a-z0-9']\+\>!\L\u\0!g<CR>yildd'ov'p"0p<Esc>

" Map Mac meta combinations (which Vim understands as the same character with
" the 8 bit set) to the same combination with the Command key (which we will
" never use).
" E.g. map <D-q>, which generates 'œ', but should generate 'ñ', to <D-q>.
map ¦ <D-`>
map ¡ <D-1>
map ™ <D-2>
map £ <D-3>
map € <D-4>
map ∞ <D-5>
map ¶ <D-7>
map ª <D-9>
map º <D-0>
map ≠ <D-=>

map ⁄ <D-!>
map € <D-">
map ‹ <D-£>
map › <D-$>
map ﬁ <D-%>
map ﬂ <D-^>
map ‡ <D-&>
map ° <D-*>
map · <D-(>
map ‚ <D-)>
map ± <D-+>

map … <D-;>
map « <D-#>
map ≤ <D-,>
map ≥ <D-.>
map ÷ <D-/>

map Ú <D-:>
map » <D-~>
map ¯ <D-<>
map ˘ <D->>
map ¿ <D-?>
map ` <D-\>

map å <D-a>
map ∫ <D-b>
map ç <D-c>
map ∂ <D-d>
map ƒ <D-f>
map © <D-g>
map ˙ <D-h>
map ∆ <D-j>
map ˚ <D-k>
map ¬ <D-l>
map µ <D-m>
map ø <D-o>
map π <D-p>
map œ <D-q>
map ® <D-r>
map ß <D-s>
map † <D-t>
map √ <D-v>
map ∑ <D-w>
map ≈ <D-x>
map ¥ <D-y>
map Ω <D-z>

map Å <D-A>
map ı <D-B>
map Ç <D-C>
map Î <D-D>
map ´ <D-E>
map Ï <D-F>
map ˝ <D-G>
map Ó <D-H>
map ˆ <D-I>
map Ô <D-J>
map  <D-K>
map Ò <D-L>
map Â <D-M>
map ˜ <D-N>
map Ø <D-O>
map ∏ <D-P>
map Œ <D-Q>
map ‰ <D-R>
map Í <D-S>
map ˇ <D-T>
map ¨ <D-U>
map ◊ <D-V>
map „ <D-W>
map ˛ <D-X>
map Á <D-Y>
map ¸ <D-Z>

map! ¦ <D-`>
map! ¡ <D-1>
map! ™ <D-2>
map! £ <D-3>
map! € <D-4>
map! ∞ <D-5>
map! ¶ <D-7>
map! ª <D-9>
map! º <D-0>
map! ≠ <D-=>

map! ⁄ <D-!>
map! € <D-">
map! ‹ <D-£>
map! › <D-$>
map! ﬁ <D-%>
map! ﬂ <D-^>
map! ‡ <D-&>
map! ° <D-*>
map! · <D-(>
map! ‚ <D-)>
map! ± <D-+>

map! … <D-;>
map! « <D-#>
map! ≤ <D-,>
map! ≥ <D-.>
map! ÷ <D-/>

map! Ú <D-:>
map! » <D-~>
map! ¯ <D-<>
map! ˘ <D->>
map! ¿ <D-?>
map! ` <D-\>

map! å <D-a>
map! ∫ <D-b>
map! ç <D-c>
map! ∂ <D-d>
map! ƒ <D-f>
map! © <D-g>
map! ˙ <D-h>
map! ∆ <D-j>
map! ˚ <D-k>
map! ¬ <D-l>
map! µ <D-m>
map! ø <D-o>
map! π <D-p>
map! œ <D-q>
map! ® <D-r>
map! ß <D-s>
map! † <D-t>
map! √ <D-v>
map! ∑ <D-w>
map! ≈ <D-x>
map! ¥ <D-y>
map! Ω <D-z>

map! Å <D-A>
map! ı <D-B>
map! Ç <D-C>
map! Î <D-D>
map! ´ <D-E>
map! Ï <D-F>
map! ˝ <D-G>
map! Ó <D-H>
map! ˆ <D-I>
map! Ô <D-J>
map!  <D-K>
map! Ò <D-L>
map! Â <D-M>
map! ˜ <D-N>
map! Ø <D-O>
map! ∏ <D-P>
map! Œ <D-Q>
map! ‰ <D-R>
map! Í <D-S>
map! ˇ <D-T>
map! ¨ <D-U>
map! ◊ <D-V>
map! „ <D-W>
map! ˛ <D-X>
map! Á <D-Y>
map! ¸ <D-Z>

" Disabled meta combinations

" Duplicate keys
"map ± <D-¬>

" Dead keys (for doing accents)
"map ` <D-\>
"map ´ <D-e>
"map ˆ <D-i>
"map ˜ <D-n>
"map ¨ <D-u>

" Useful ones to keep
"map • <D-8>
"map – <D-->
"map — <D-_>
"map ’ <D-6>
"map “ <D-[>
"map ‘ <D-]>
"map ” <D-{>
"map ’ <D-}>

